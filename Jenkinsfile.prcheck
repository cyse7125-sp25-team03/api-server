void setBuildStatus(String message, String state) {
  step([
      $class: "GitHubCommitStatusSetter",
      contextSource: [$class: "ManuallyEnteredCommitContextSource", context: "ci/jenkins/build-status"],
      errorHandlers: [[$class: "ChangingBuildStatusErrorHandler", result: "UNSTABLE"]],
      statusResultSource: [ $class: "ConditionalStatusResultSource", results: [[$class: "AnyBuildResult", message: message, state: state]] ]
  ]);
}

pipeline {
    agent any
    
    options {
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
    }
    stages {
        stage('Initialize Build') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                    setBuildStatus("Build is starting...'", "PENDING");
                }
            }
        }
        stage('Checkout Code') {
            steps {
                checkout scm
            }
        }
        
        stage('PR Validation') {
            steps {
                script {
                    echo "This is a PR validation for PR#${env.CHANGE_ID}"
                    sh 'docker build --no-cache -t test-build .'
                }
            }
        }

        stage('Calculate Version') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                    script {
                        // Set Git credentials for the script
                        sh """
                            git config credential.helper store
                            echo "https://${GITHUB_USERNAME}:${GITHUB_TOKEN}@github.com" > ~/.git-credentials
                            chmod 600 ~/.git-credentials
                        """
                        
                        // Create version calculation script
                        writeFile file: 'calculate_version.sh', text: '''#!/bin/bash
                        calculate_version() {
                            # Fetch all tags first
                            git fetch --tags || echo "Failed to fetch tags"

                            # Get latest tag or default to v0.0.0 if none exists
                            LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
                            
                            MAJOR=$(echo $LATEST_TAG | cut -d. -f1 | tr -d 'v')
                            MINOR=$(echo $LATEST_TAG | cut -d. -f2)
                            PATCH=$(echo $LATEST_TAG | cut -d. -f3)
                            
                            COMMIT_MSG=$(git log -1 --pretty=%B)
                            
                            # Determine version bump type based on commit message
                            if echo "$COMMIT_MSG" | grep -qE "^[a-z]+\\([a-z]+\\)!:" || echo "$COMMIT_MSG" | grep -q "BREAKING CHANGE"; then
                                VERSION_TYPE="MAJOR"
                                MAJOR=$((MAJOR + 1))
                                MINOR=0
                                PATCH=0
                            elif echo "$COMMIT_MSG" | grep -qE "^feat\\([a-z]+\\):"; then
                                VERSION_TYPE="MINOR"
                                MINOR=$((MINOR + 1))
                                PATCH=0
                            else
                                VERSION_TYPE="PATCH"
                                PATCH=$((PATCH + 1))
                            fi
                            
                            NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
                            
                            # Check if tag already exists and handle according to semantic versioning
                            while git rev-parse "$NEW_VERSION" >/dev/null 2>&1 || git ls-remote --tags origin | grep -q "refs/tags/${NEW_VERSION}"; do
                                echo "Warning: Tag $NEW_VERSION already exists, incrementing according to change type"
                                
                                if [ "$VERSION_TYPE" = "MAJOR" ]; then
                                    MAJOR=$((MAJOR + 1))
                                    MINOR=0
                                    PATCH=0
                                elif [ "$VERSION_TYPE" = "MINOR" ]; then
                                    MINOR=$((MINOR + 1))
                                    PATCH=0
                                else
                                    PATCH=$((PATCH + 1))
                                fi
                                
                                NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
                                echo "Trying new version: $NEW_VERSION"
                            done
                            
                            echo "$NEW_VERSION"
                        }

                        calculate_version
                        '''
                        // Make script executable and run it with bash explicitly
                        sh 'chmod 755 calculate_version.sh'
                        env.NEW_VERSION = sh(returnStdout: true, script: '/bin/bash calculate_version.sh').trim()
                        echo "Building version: ${env.NEW_VERSION}"
                        
                        // Clean up credentials after use
                        sh """
                            rm -f ~/.git-credentials
                        """
                    }
                }
            }
        }
    }    
    
    post {
        success {
                withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                    setBuildStatus("Build succeeded'", "SUCCESS");
                }
        }
        failure {
            withCredentials([usernamePassword(credentialsId: 'github-pat', usernameVariable: 'GITHUB_USERNAME', passwordVariable: 'GITHUB_TOKEN')]) {
                setBuildStatus("Build failed'", "FAILURE");
            }
        }
        always {
            cleanWs()
        }
    }
}